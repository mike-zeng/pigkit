package pigrpc

import (
	"fmt"
	pb "github.com/golang/protobuf/protoc-gen-go/descriptor"
	"pigkit/protoc-gen-pigrpc/generator"
	"strings"
)

// Paths for packages used by code generated in this file,
// relative to the import_prefix of the generator.Generator.
const (
	PigRpcServerPkgPath      = "github.com/mike-zeng/pigkit/rpc"
)

func init() {
	generator.RegisterPlugin(new(pigrpc))
}

type pigrpc struct {
	gen *generator.Generator
}

//Name returns the name of this plugin
func (p *pigrpc) Name() string {
	return "pigrpc"
}

//Init initializes the plugin.
func (p *pigrpc) Init(gen *generator.Generator) {
	p.gen = gen
}

// Given a type name defined in a .proto, return its object.
// Also record that we're using it, to guarantee the associated import.
func (p *pigrpc) objectNamed(name string) generator.Object {
	p.gen.RecordTypeUse(name)
	return p.gen.ObjectNamed(name)
}

// Given a type name defined in a .proto, return its name as we will print it.
func (p *pigrpc) typeName(str string) string {
	return p.gen.TypeName(p.objectNamed(str))
}

// GenerateImports generates the import declaration for this file.
func (p *pigrpc) GenerateImports(file *generator.FileDescriptor) {
}

// P forwards to g.gen.P.
func (p *pigrpc) P(args ...interface{}) { p.gen.P(args...) }

// Generate generates code for the services in the given file.
func (p *pigrpc) Generate(file *generator.FileDescriptor) {

	if len(file.FileDescriptorProto.Service) == 0 {
		return
	}
	// 导入包
	_ = p.gen.AddImport(PigRpcServerPkgPath)
	_ = p.gen.AddImport("context")

	for i, service := range file.FileDescriptorProto.Service {
		p.generateService(file, service, i)
	}
}

// generateService generates all the code for the named service
func (p *pigrpc) generateService(file *generator.FileDescriptor, service *pb.ServiceDescriptorProto, index int) {
	originServiceName := service.GetName()
	serviceName := upperFirstLatter(originServiceName)
	p.P("// This following code was generated by protoc-gen-pigrpc, DO NOT EDIT!!!")
	p.P()
	p.P("//================== server skeleton ===================")
	p.P(fmt.Sprintf(`type %sService interface {
				`, serviceName))

	for _, method := range service.Method {
		p.generateServerInterfaceCode(method)
	}
	p.P("}")

	p.generateServiceDesc(service, file.GetPackage())
	for _, method := range service.Method {
		p.generateServerCode(service, method, file.GetPackage())
	}
	//p.generateRegisterCode(service)
	p.P("//================== client stub===================")
	//p.P(fmt.Sprintf(`//%sClientProxy is a client proxy for service %s.
	//	type %sClientProxy interface {
	//`, serviceName, serviceName, serviceName))
	//for _, method := range service.Method {
	//	p.generateClientInterfaceCode(method)
	//}
	//p.P("}")
	//p.P(fmt.Sprintf(`
	//	type %sClientProxyImpl struct {
	//		client client.Client
	//		opts   []client.Option
	//	}
	//`, serviceName))
	//p.P(fmt.Sprintf(`
	//	func New%sClientProxy(opts ...client.Option) %sClientProxy {
	//		return &%sClientProxyImpl{client: client.DefaultClient, opts: opts}
	//	}
	//`, serviceName, serviceName, serviceName))
	//
	//for _, method := range service.Method {
	//	p.generateClientCode(service, method, file.GetPackage())
	//}
	//
}

func (p *pigrpc) generateRegisterCode(service *pb.ServiceDescriptorProto) {
	serviceName := upperFirstLatter(service.GetName())
	p.P(fmt.Sprintf(`
		func RegisterService(s *pigrpc.Server, svr interface{}) {
			s.Register(_%s_serviceDesc, svr)
		}
	`, serviceName))
}

func (p *pigrpc) generateServiceDesc(service *pb.ServiceDescriptorProto, pkgPath string) {

	serviceName := upperFirstLatter(service.GetName())
	p.P(fmt.Sprintf(`var %sServiceDesc = &service.ServiceDesc {
		ServiceName: "%s.%s",
		HandlerType: (*%sService)(nil),
		Methods: map[string]service.Handler {
	`, serviceName, pkgPath,serviceName,serviceName))

	for _, method := range service.Method {
		methodName := upperFirstLatter(method.GetName())
		p.P(fmt.Sprintf(`"%s": %sService_%s_Handler,`, methodName, serviceName, methodName))
	}

	p.P("},")
	p.P("}")
}

func (p *pigrpc) generateServerInterfaceCode(method *pb.MethodDescriptorProto) {
	methodName := upperFirstLatter(method.GetName())
	inType := p.typeName(method.GetInputType())
	outType := p.typeName(method.GetOutputType())
	p.P(fmt.Sprintf("%s(ctx context.Context, req *%s)(*%s, error)",
		methodName, inType, outType))
}

func (p *pigrpc) generateServerCode(service *pb.ServiceDescriptorProto, method *pb.MethodDescriptorProto, pkgName string) {
	methodName := upperFirstLatter(method.GetName())
	serviceName := upperFirstLatter(service.GetName())
	inType := p.typeName(method.GetInputType())
	p.P(fmt.Sprintf(`
		func %sService_%s_Handler(ctx context.Context,s interface{},pigReq *codec.PigReq,fillReq func(interface{},*codec.PigReq)error)(interface{},error){
			req := new(%s)
			if err := fillReq(req,pigReq); err != nil {
				return nil, err	
			}
			return s.(%sService).%s(ctx, req)
		}
	`, serviceName, methodName, inType, serviceName, methodName))
}

func (p *pigrpc) generateClientCode(service *pb.ServiceDescriptorProto, method *pb.MethodDescriptorProto, pkgName string) {
	methodName := upperFirstLatter(method.GetName())
	serviceName := upperFirstLatter(service.GetName())
	inType := p.typeName(method.GetInputType())
	outType := p.typeName(method.GetOutputType())
	p.P(fmt.Sprintf(`// %s is server rpc method as defined
		func (c *%sClientProxyImpl) %s(ctx context.Context, req *%s, opts ...client.Option) (*%s ,error){
			
			callopts := make([]client.Option, 0, len(c.opts)+len(opts))
			callopts = append(callopts, c.opts...)
			callopts = append(callopts, opts...)

			rsp := &%s{}
			err := c.client.Invoke(ctx, req, rsp, "/%s.%s/%s", callopts...)
			if err != nil {
				return nil, err
			}

			return rsp, nil
		}
	`, methodName, serviceName, methodName, inType, outType, outType, pkgName, serviceName, methodName))
}

func (p *pigrpc) generateClientInterfaceCode(method *pb.MethodDescriptorProto) {
	methodName := upperFirstLatter(method.GetName())
	inType := p.typeName(method.GetInputType())
	outType := p.typeName(method.GetOutputType())
	p.P(fmt.Sprintf("%s(ctx context.Context, req *%s, opts ...client.Option)(*%s, error)",
		methodName, inType, outType))
}


// upperFirstLatter make the fisrt charater of given string  upper class
func upperFirstLatter(s string) string {
	if len(s) == 0 {
		return ""
	}
	if len(s) == 1 {
		return strings.ToUpper(string(s[0]))
	}
	return strings.ToUpper(string(s[0])) + s[1:]
}
