package pigrpc

import (
	"fmt"
	pb "github.com/golang/protobuf/protoc-gen-go/descriptor"
	"github/mike-zeng/pigkit/protoc-gen-pigrpc/generator"
	"strings"
)

// ServerPkgPath Paths for packages used by code generated in this file,
// relative to the import_prefix of the generator.Generator.
const (
	ServerPkgPath = "github.com/mike-zeng/pigkit/rpc/server"
	CodecPkgPath = "github.com/mike-zeng/pigkit/rpc/codec"
	ClientPkgPath = "github.com/mike-zeng/pigkit/rpc/client"
)

func init() {
	generator.RegisterPlugin(new(pigrpc))
}

type pigrpc struct {
	gen *generator.Generator
}

const (
	GenServer = "server"
	GenClient = "client"
	GenHandlerImpl = "handler"
)
//Name returns the name of this plugin
func (p *pigrpc) Name() string {
	return "pigrpc"
}

//Init initializes the plugin.
func (p *pigrpc) Init(gen *generator.Generator) {
	p.gen = gen
}

// Given a type name defined in a .proto, return its object.
// Also record that we're using it, to guarantee the associated import.
func (p *pigrpc) objectNamed(name string) generator.Object {
	p.gen.RecordTypeUse(name)
	return p.gen.ObjectNamed(name)
}

// Given a type name defined in a .proto, return its name as we will print it.
func (p *pigrpc) typeName(str string) string {
	return p.gen.TypeName(p.objectNamed(str))
}

// GenerateImports generates the import declaration for this file.
func (p *pigrpc) GenerateImports(file *generator.FileDescriptor) {
}

// P forwards to g.gen.P.
func (p *pigrpc) P(args ...interface{}) { p.gen.P(args...) }

// Generate generates code for the services in the given file.
func (p *pigrpc) Generate(file *generator.FileDescriptor) {

	if len(file.FileDescriptorProto.Service) == 0 {
		return
	}
	// 导入包
	_ = p.gen.AddImport("context")

	for i, service := range file.FileDescriptorProto.Service {
		p.generateService(file, service, i)
	}
}

// generateService generates all the code for the named service
func (p *pigrpc) generateService(file *generator.FileDescriptor, service *pb.ServiceDescriptorProto, index int) {
	// judge gen object
	s,ok := p.gen.Param["gen_obj"]
	if !ok || (s!="server"&&s!="client"){
		s = "server"
	}
	if s == "server" {
		p.gen.AddImport(ServerPkgPath)
		p.gen.AddImport(CodecPkgPath)
		originServiceName := service.GetName()
		serviceName := upperFirstLatter(originServiceName)
		p.P("// This following code was generated by protoc-gen-pigrpc, DO NOT EDIT!!!")
		p.P()
		p.P("//================== server skeleton ===================")
		p.P(fmt.Sprintf(`type %sService interface {
				`, serviceName))
		for _, method := range service.Method {
			p.generateServerInterfaceCode(method)
		}
		p.P("}")

		p.generateServiceDesc(service, file.GetPackage())
		for _, method := range service.Method {
			p.generateServerCode(service, method, file.GetPackage())
		}
	}else {
		p.gen.AddImport(ClientPkgPath)
		p.gen.AddImport(CodecPkgPath)
		originServiceName := service.GetName()
		serviceName := upperFirstLatter(originServiceName)
		p.P("// This following code was generated by protoc-gen-pigrpc, DO NOT EDIT!!!")
		p.P("//================== client stub===================")
		p.P(fmt.Sprintf(`type %sClientProxy struct {
	client client.Client
				`, serviceName))
		p.P("}")
		for _, method := range service.Method {
			p.generateClientProxyMethodCode(serviceName,method)
		}
		// service register callback
		p.P(fmt.Sprintf(`func (p %sClientProxy)RegisterCallback(client client.Client) {
		p.client = client
}`,serviceName))

		p.P(fmt.Sprintf(`func (p %sClientProxy)GetProxyServiceName()string {
		return "%s"
}`,serviceName,serviceName))
	}
}

func (p *pigrpc) generateRegisterCode(service *pb.ServiceDescriptorProto) {
	serviceName := upperFirstLatter(service.GetName())
	p.P(fmt.Sprintf(`
		func RegisterService(s *pigrpc.Server, svr interface{}) {
			s.Register(_%s_serviceDesc, svr)
		}
	`, serviceName))
}

func (p *pigrpc) generateServiceDesc(service *pb.ServiceDescriptorProto, pkgPath string) {

	serviceName := upperFirstLatter(service.GetName())
	p.P(fmt.Sprintf(`var %sServiceDesc = &server.ServiceDesc {
		ServiceName: "%s.%s",
		HandlerType: (*%sService)(nil),
		Methods: map[string]server.Handler {
	`, serviceName, pkgPath,serviceName,serviceName))

	for _, method := range service.Method {
		methodName := upperFirstLatter(method.GetName())
		p.P(fmt.Sprintf(`"%s": %sService_%s_Handler,`, methodName, serviceName, methodName))
	}

	p.P("},")
	p.P("}")
}

func (p *pigrpc) generateServerInterfaceCode(method *pb.MethodDescriptorProto) {
	methodName := upperFirstLatter(method.GetName())
	inType := p.typeName(method.GetInputType())
	outType := p.typeName(method.GetOutputType())
	p.P(fmt.Sprintf("%s(ctx context.Context, req *%s)(*%s, error)",
		methodName, inType, outType))
}

func (p *pigrpc) generateServerCode(service *pb.ServiceDescriptorProto, method *pb.MethodDescriptorProto, pkgName string) {
	methodName := upperFirstLatter(method.GetName())
	serviceName := upperFirstLatter(service.GetName())
	inType := p.typeName(method.GetInputType())
	p.P(fmt.Sprintf(`
		func %sService_%s_Handler(ctx context.Context,s interface{},pigReq *codec.PigReq,fillReq func(interface{},*codec.PigReq)error)(interface{},error){
			req := new(%s)
			if err := fillReq(req,pigReq); err != nil {
				return nil, err	
			}
			return s.(%sService).%s(ctx, req)
		}
	`, serviceName, methodName, inType, serviceName, methodName))
}

func (p *pigrpc) generateClientProxyMethodCode(serviceName string,method *pb.MethodDescriptorProto) {
	inType := p.typeName(method.GetInputType())
	outType := p.typeName(method.GetOutputType())
	p.P(fmt.Sprintf(`func (proxy *%sClientProxy)%s(ctx context.Context,req *%s)(*%s,error) {`,
		serviceName,*method.Name,inType,outType))
	p.P(fmt.Sprintf(`
			options := client.Options{
				ServiceName:       "%s",
				Method:            "%s",
				Timeout:           0,
				SerializationType: "proto",
			}
			resp, err := proxy.client.Call(ctx, req, options)
			if err != nil {
				return nil, err
			}
			serialization := codec.GetSerialization(options.SerializationType)
			ret := %s{}
			err = serialization.Unmarshal(resp, &ret)
			if err != nil {
				return nil,err
			}
			return &ret, nil`,serviceName,*method.Name,outType))
	p.P("}")
}


// upperFirstLatter make the fisrt charater of given string  upper class
func upperFirstLatter(s string) string {
	if len(s) == 0 {
		return ""
	}
	if len(s) == 1 {
		return strings.ToUpper(string(s[0]))
	}
	return strings.ToUpper(string(s[0])) + s[1:]
}
